---
layout : single
title : "Fast Fourier Transform"
date : 2020-05-17
categories : jekyll update
use_math : true
---



# FFT (Fast Fourier Transform) 알고리즘

201701691 이상민



FFT 알고리즘, 한국어로 '고속 푸리에 변환' 알고리즘이라 합니다. 이 알고리즘은 '이산 푸리에 변환'(줄여서 DFT)의 계산 수를 줄이기 위해 변형한 알고리즘입니다. 그렇다면 '푸리에 변환'이 무엇인지 먼저 설명하겠습니다.



## Fourier Transform (푸리에 변환)

'푸리에'는 18세기 프랑스의 수학자입니다. 그는 고체 내에서의 열 전도에 관한 연구 끝에 '열전도 방정식'을 유도하였으며 그 방정식을 유도하는 데에 쓰인 것이 바로 '푸리에 해석'이라는 이론입니다.



푸리에 해석은 푸리에 급수나 푸리에 변환을 이용해 함수를 해석하는 것인데 핵심은 해석하고자 하는 함수의 차원을 변경하는 것입니다. 그래서 푸리에는 '차원 해석'의 창시자로 여겨집니다.



푸리에 해석은 현대에서는 대표적으로 시간 영역의 주파수 함수를 주파수 영역에서의 함수로 관찰할 때 주로 쓰입니다. 시간 영역에서의 관찰은 한계가 있기 때문입니다. (무한한 시간을 모두 표현할 수 가 없음.)



여기서 푸리에 급수(Fourier Series)는 함수가 주기를 가지고 있을 때의 해석이고 **푸리에 변환(Fourier Transform)**은 주기 혹은 비주기함수 모두 사용할 수 있습니다. 즉 푸리에 급수의 확장된 개념입니다.



## DFT (Discrete Fourier Transform) (이산 푸리에 변환)

푸리에 변환이 시간 영역의 함수를 주파수 영역의 함수로 바꿔서 해석한다는 것을 알았는데, 우리가 또 알아야 할 건 '이산 푸리에 변환'이라는 것입니다. 이 변환을 사용하는 이유는 무엇일까요?



바로 컴퓨터와 같은 디지털 신호 처리 장치가 연속적으로 데이터를 저장하는 것이 아니기 때문입니다. 기존 푸리에 변환은 연속함수를 변환하는 방법이어서 컴퓨터에 적합하지 않았습니다. 그래서 발견한 것이 이산 푸리에 변환 (DFT) 입니다. 즉, 이산 푸리에 변환은 함수가 아닌 표본화된 값(sampled value)을 다루는 것입니다.



이산 푸리에 변환 식은 다음과 같습니다.



$X(k) = \sum_{n=0}^{N-1}x(n)e^{-j\frac{2\pi}Nkn}$



$$N$$은 한 주기를 구성하는 표본의 수입니다. 기존의 푸리에 변환이 주기를 가진 연속된 함수라면 $$N$$개의 표본으로 잘라서 표현하는 것이 이산 푸리에 변환의 핵심입니다. $N$은 또 시간함수의 주파수 성분의 개수로도 표현할 수 있겠습니다.

$n$은 시간함수의 표본의 순번이 될 것이고 $k$는 변환된 주파수 함수의 성분의 순번이 될 것입니다.

$j$는 허수입니다.



식을 자세히 보면 복소수 성분을 곱하는 연산 $N^2$번, 곱한 식을 더해주는 연산 $N(N-1)$번. 총 $N^2$번의 연산을 하게 됩니다. 즉 시간 복잡도가 $O(N^2)$라는 뜻이 됩니다. 이것은 매우 비효율적입니다. 만약 $N$의 값이 10만 되어도 연산은 무려 100번을 하게 된다는 뜻입니다. 그래서 학자들이 생각해 낸 것이 '고속 푸리에 변환(Fast Fourier Transform)', 줄여서 FFT라고 하는 빠르게 DFT를 할 수 있는 기법입니다.



## FFT (Fast Fourier Transform) (고속 푸리에 변환)



FFT의 핵심은 분할정복(Divide and Conquer)입니다. 표본의 수 $N$을 분할하여 계산해서 합쳐주면 연산량이 줄어든다는 생각으로 고안되었습니다.

예를 들어 $N=8$일 때, DFT로는 총 64번의 연산을 한다고 하면, $N=4$인 DFT 두 개로 분할하고 결합하는 연산을 더해 주면, 더 적게 연산을 하고 같은 결과를 낸다는 것입니다.

수식적으로 표현해보겠습니다.



표본의 수가 $N$인 $x(n)$을 표본 $N/2$의 $p(n)$과 $q(n)$으로 분해합니다. $p(n)$은 짝수, $q(n)$은 홀수로 생각해봅니다.



$p(n) = x(2n), q(n) = x(2n+1), 0<=n<=N/2 -1$



$X(k) = \sum_{n=0}^{N-1}x(n)e^{-j\frac{2\pi}Nkn}$

​			$= \sum_{n=even}^{N-1}x(n)e^{-j\frac{2\pi}{N}kn} + \sum_{n=odd}^{N-1}x(n)e^{-j\frac{2\pi}{N}kn}$

​			$= \sum_{n=0}^{\frac{N}{2}-1}x(2n)e^{-j\frac{2\pi}{N}2kn} + \sum_{n=0}^{\frac{N}{2}-1}x(2n+1)e^{-j\frac{2\pi}{N}k(2n+1)}$

​			$= \sum_{n=0}^{\frac{N}{2}-1}p(n)e^{-j\frac{2\pi}{(N/2)}kn} + e^{-j\frac{2\pi}{N}k}\sum_{n=0}^{\frac{N}{2}-1}q(n)e^{-j\frac{2\pi}{N/2}kn}$ , $0<=k<=N-1$         ---- (1)



식 (1)을 보면 하나의 DFT가 2개의 DFT로 나뉘어진 것을 알 수 있습니다. 첫번째 변환을 $P(k)$, 두번째 변환을 $Q(k)$라고 하겠습니다.



이 FFT 식을 분석해보겠습니다. 여기서 $N=8$로 가정하고 $e^{-j\frac{2\pi}{N}kn} = W_N^{kn}$로 두겠습니다. 

$X(k) = \sum_{n=0}^{N-1}x(n)e^{-j\frac{2\pi}{N}kn}$

 	 $= x(0)e^{-j\frac{2\pi}{N}0} + x(1)e^{-j\frac{2\pi}{N}1} + ... + x(7)e^{-j\frac{2\pi}{N}7}$

  	$= x(0)W_4^0 + x(2)W_4^k + x(4)W_4^{2k} + x(6)W_4^{3k} + W_8^k(x(1)W_4^0 + x(3)W_4^k + x(5)W_4^{2k} + x(7)W_4^{3k})$



식 (1)에 의해 $N=4$인 $P(k)$와 $Q(k)$로 분할됩니다. 여기서 $P(k)$를 보겠습니다.

$P(k) = x(0)W_4^0 + x(2)W_4^k + x(4)W_4^{2k} + x(6)W_4^{3k}$

​		  $= x(0)W_2^0 + x(4)W_2^k + W_4^k(x(2)W_2^0 + x(6)W_2^k)$



$N=2$인 $A(k)$와 $B(k)$로 분할됩니다.

$A(k) = x(0)W_2^0 + x(4)W_2^k$



이제 더이상 분할할 필요가 없습니다. 여기서 $A(0)$과 $A(1)$를 구해봅니다.

$A(0) = x(0) + x(4)$   -------- $W_2^0, W_2^k$ 모두 지수가 0이므로 1로 바뀜

$A(1) = x(0) - x(4)$   -------- $W_2^0 = 1$, $W_2^k = e^{-j\pi} = -1$ (오일러의 항등식)



$N=2$까지 분할을 하니 식이 간단하게 표현됩니다.

이런 방식으로 $B(k)$, 그리고 $Q(k)$로 부터 분할된 $C(k), D(k)$를 구할 수 있을 것입니다. 그렇다면 기존 DFT보다 더 빠른 연산이 가능합니다.



$N=4$인 $X(k)$를 $P(k)$와 $Q(k)$로 분할하여 변환하는 흐름도는 대략 이렇습니다.

![Butterfly](https://user-images.githubusercontent.com/63089782/82148279-47774c00-988e-11ea-8c43-9ccc7b7c6239.jpg)

화살표끼리 더하면 되고, -1이 써있는 부분은 -1을 곱해서 더하면 됩니다.

보시면 분할 정복의 개념이 한눈에 들어오는 것을 알 수 있습니다.



시간복잡도는 기존의 DFT와 비교해서 얼마나 나아졌을까요?  표본 수 $N$일 때 1에서 $N$까지 2를 $x$번 곱한다고 가정합니다. (분할정복의 핵심인, 무조건 데이터를 둘로 나누어 연산하기 때문에 이를 역으로 계산해봅니다.)

$ N = 2^{x}$

양 변에 로그를 취하면, 

$log_{2}N = log_{2}{2^x}$

$x = log_{2}N$의 결과를 가져옵니다. 표본 1개 당 연산이기 때문에 $N$개의 표본인데, $N=2$에서 $N=1$로 분할하지 않으므로 $N/2$번 의 연산을 합니다.

따라서 연산 수는 $N/2log_{2}N$이고 시간복잡도는 $O(nlogn)$이 됩니다. 기존 DFT $O(n^2)$보다 확연히 성능이 뛰어남을 알 수 있습니다.





FFT 코드 구현은 코딩 실력이 부족하여 해결하지 못했습니다. 더 공부해서 채워넣겠습니다...







